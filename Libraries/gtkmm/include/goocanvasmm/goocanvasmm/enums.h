// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GOOCANVASMM_ENUMS_H
#define _GOOCANVASMM_ENUMS_H


#include <glibmm/ustring.h>
#include <sigc++/sigc++.h>

/* Copyright (C) 1998-2006 The gtkmm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <goocanvasutils.h>

#include <cairomm/enums.h>
#include <cairomm/pattern.h>
#include <cairomm/context.h> // For Cairo::Matrix
#include <glibmm/value.h>


namespace Goocanvas
{

/** @addtogroup goocanvasmmEnums goocanvasmm Enums and Flags */

/** 
 * 
 * @ingroup goocanvasmmEnums
 * @par Bitwise operators:
 * <tt>%PointerEvents operator|(PointerEvents, PointerEvents)</tt><br>
 * <tt>%PointerEvents operator&(PointerEvents, PointerEvents)</tt><br>
 * <tt>%PointerEvents operator^(PointerEvents, PointerEvents)</tt><br>
 * <tt>%PointerEvents operator~(PointerEvents)</tt><br>
 * <tt>%PointerEvents& operator|=(PointerEvents&, PointerEvents)</tt><br>
 * <tt>%PointerEvents& operator&=(PointerEvents&, PointerEvents)</tt><br>
 * <tt>%PointerEvents& operator^=(PointerEvents&, PointerEvents)</tt><br>
 */
enum PointerEvents
{
  EVENTS_VISIBLE_MASK = 1 << 0,
  EVENTS_PAINTED_MASK = 1 << 1,
  EVENTS_FILL_MASK = 1 << 2,
  EVENTS_STROKE_MASK = 1 << 3,
  EVENTS_NONE = 0x0,
  EVENTS_VISIBLE_PAINTED = 0xF,
  EVENTS_VISIBLE_FILL = 0x5,
  EVENTS_VISIBLE_STROKE = 0x9,
  EVENTS_VISIBLE = 0xD,
  EVENTS_PAINTED = 0xE,
  EVENTS_FILL = 0x4,
  EVENTS_STROKE = 0x8,
  EVENTS_ALL = 0xC
};

/** @ingroup goocanvasmmEnums */
inline PointerEvents operator|(PointerEvents lhs, PointerEvents rhs)
  { return static_cast<PointerEvents>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents operator&(PointerEvents lhs, PointerEvents rhs)
  { return static_cast<PointerEvents>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents operator^(PointerEvents lhs, PointerEvents rhs)
  { return static_cast<PointerEvents>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents operator~(PointerEvents flags)
  { return static_cast<PointerEvents>(~static_cast<unsigned>(flags)); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents& operator|=(PointerEvents& lhs, PointerEvents rhs)
  { return (lhs = static_cast<PointerEvents>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents& operator&=(PointerEvents& lhs, PointerEvents rhs)
  { return (lhs = static_cast<PointerEvents>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup goocanvasmmEnums */
inline PointerEvents& operator^=(PointerEvents& lhs, PointerEvents rhs)
  { return (lhs = static_cast<PointerEvents>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Goocanvas


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Goocanvas::PointerEvents> : public Glib::Value_Flags<Goocanvas::PointerEvents>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Goocanvas
{

/** 
 * 
 * @ingroup goocanvasmmEnums
 */
enum ItemVisibility
{
  ITEM_HIDDEN,
  ITEM_INVISIBLE,
  ITEM_VISIBLE,
  ITEM_VISIBLE_ABOVE_THRESHOLD
};

} // namespace Goocanvas


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Goocanvas::ItemVisibility> : public Glib::Value_Enum<Goocanvas::ItemVisibility>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Goocanvas
{

/** 
 * 
 * @ingroup goocanvasmmEnums
 */
enum PathCommandType
{
  PATH_MOVE_TO,
  PATH_CLOSE_PATH,
  PATH_LINE_TO,
  PATH_HORIZONTAL_LINE_TO,
  PATH_VERTICAL_LINE_TO,
  PATH_CURVE_TO,
  PATH_SMOOTH_CURVE_TO,
  PATH_QUADRATIC_CURVE_TO,
  PATH_SMOOTH_QUADRATIC_CURVE_TO,
  PATH_ELLIPTICAL_ARC
};

} // namespace Goocanvas


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Goocanvas::PathCommandType> : public Glib::Value_Enum<Goocanvas::PathCommandType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Goocanvas
{

/** 
 * 
 * @ingroup goocanvasmmEnums
 */
enum AnchorType
{
  ANCHOR_CENTER,
  ANCHOR_NORTH,
  ANCHOR_NORTH_WEST,
  ANCHOR_NORTH_EAST,
  ANCHOR_SOUTH,
  ANCHOR_SOUTH_WEST,
  ANCHOR_SOUTH_EAST,
  ANCHOR_WEST,
  ANCHOR_EAST,
  ANCHOR_N = ANCHOR_NORTH,
  ANCHOR_NW = ANCHOR_NORTH_WEST,
  ANCHOR_NE = ANCHOR_NORTH_EAST,
  ANCHOR_S = ANCHOR_SOUTH,
  ANCHOR_SW = ANCHOR_SOUTH_WEST,
  ANCHOR_SE = ANCHOR_SOUTH_EAST,
  ANCHOR_W = ANCHOR_WEST,
  ANCHOR_E = ANCHOR_EAST
};

} // namespace Goocanvas


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Goocanvas::AnchorType> : public Glib::Value_Enum<Goocanvas::AnchorType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Goocanvas
{


} //namespace Goocanvas

namespace Glib
{

#ifndef DOXYGEN_SHOULD_SKIP_THIS
// Make the cairo enums and structures work with Glib::Value using the
// GTypes goocanvas defines for them in goocanvasutil.h

template<>
class Value<Cairo::Matrix*> : public Glib::ValueBase_Boxed
{
public:
  static GType value_type() G_GNUC_CONST;

  void set(const Cairo::Matrix* data) { set_boxed(data); }
  Cairo::Matrix* get() const { return static_cast<Cairo::Matrix*>(get_boxed()); }
};

template<>
class Value<Cairo::FillRule> : public Glib::Value_Enum<Cairo::FillRule>
{
public:
  static GType value_type() G_GNUC_CONST;
};

template<>
class Value<Cairo::Operator> : public Glib::Value_Enum<Cairo::Operator>
{
public:
  static GType value_type() G_GNUC_CONST;
};

template<>
class Value<Cairo::Antialias> : public Glib::Value_Enum<Cairo::Antialias>
{
public:
  static GType value_type() G_GNUC_CONST;
};

template<>
class Value<Cairo::LineCap> : public Glib::Value_Enum<Cairo::LineCap>
{
public:
  static GType value_type() G_GNUC_CONST;
};

template<>
class Value<Cairo::LineJoin> : public Glib::Value_Enum<Cairo::LineJoin>
{
public:
  static GType value_type() G_GNUC_CONST;
};

template<>
class Value<Cairo::HintMetrics> : public Glib::Value_Enum<Cairo::HintMetrics>
{
public:
  static GType value_type() G_GNUC_CONST;
};

#endif // DOXYGEN_SHOULD_SKIP_THIS

}


#endif /* _GOOCANVASMM_ENUMS_H */

